/*
A granular delay. 

Best Cmajor practices are not mostly followed yet, the code started pretty
much as a port of some C++ code I did recently.

Issues :
- Resampling could be done with a better algorithm instead of the linear interpolation
- The grain envelope shapes could be more imaginative

-Xenakios, September 2024
*/

graph graindelay  [[ main ]]
{
    input stream float<2> audio_in;
    output stream float<2> audio_out;
    
    input value float freezeInput [[ name: "Freeze input", text: "off|on", boolean ]];
    input value float density [[ name: "Density", min: -1.0f, max: 1.0f, init: -0.3f ]];
    input value float size [[ name: "Size", min: 0.0f, max: 1.0f, init: 0.5f ]];
    input value float shape [[ name: "Shape", min: 0.0f, max: 1.0f, init: 1.0f ]];
    input value float position [[ name: "Time", min: 0.0f, max: 1.0f, init: 0.5f ]];
    input value float positionrand [[ name: "Time rnd", min: -1.0f, max: 1.0f, init: 0.0f ]];
    input value float pitch [[ name: "Pitch", min: -12.0f, max: 12.0f, init: 0.0f ]];
    input value float pitchrand [[ name: "Pitch rnd", min: -1.0f, max: 1.0f, init: 0.0f ]];
    input value float chance [[ name: "Probability", min: 0.0f, max: 1.0f, init: 1.0f ]];
    input value float panmode [[ name: "Pan", text: "center|alt L/R|sine" ]];
    input value float mainvol [[ name: "Output gain", min: 0.0f, max: 1.0f, init: 0.1f ]];
    input value float drywet [[ name: "Mix", min: 0.0f, max: 1.0f, init: 1.0f ]];
    node engine = GrainDelayEngine;
    connection
    {
        audio_in -> engine.audio_in;
        density -> engine.grainrate;
        position -> engine.grainposition;
        size -> engine.grainsize;
        pitch -> engine.grainpitch;
        freezeInput -> engine.inputFrozen;
        chance -> engine.grainChance;
        mainvol -> engine.mainvol;
        shape -> engine.grainshape;
        drywet -> engine.drywet;
        panmode -> engine.panmode;
        positionrand -> engine.positionrand;
        pitchrand -> engine.pitchrand;
        engine.audio_out -> audio_out;
    }
}

processor GrainDelayEngine
{
    input stream float<2> audio_in;
    input stream float grainposition;
    input stream float grainrate;
    input stream float grainsize;
    input stream float grainpitch;
    input stream float grainshape;
    input stream float inputFrozen;
    input stream float grainChance;
    input stream float mainvol;
    input stream float drywet;
    input stream float panmode;
    input stream float positionrand;
    input stream float pitchrand;
    output stream float<2> audio_out;
    
    let maxDelayLength = 10 * 44100;
    float<2>[maxDelayLength] delayBuffer;
    wrap<maxDelayLength> writeIndex;
    struct PlayHead
    {
        bool isActive;
        float64 sourceReadPos;
        int lenSamples;
        int outPlaypos;
        float playRate;
        int fadelensamples;
        float<2> pangains;
    }
    let numPlayheads = 32;
    PlayHead[numPlayheads] playheads;
    std::random::RNG rng;
    float getBipolarRandom(float param, std::random::RNG& rng)
    {
        float z = rng.getUnipolar();
        if (param<0.0f)
        {
            float temp=abs(param);
            temp = pow(temp,2.0f);
            float cauchy = 0.1f * temp * tan(float(pi)*(z-0.5f));
            return clamp(cauchy,-1.0f,1.0f);
        } else
        {
            float temp=pow(param,2.0f);
            float halfrange = temp / 2;
            return -halfrange+temp*z;
        }
        return 0.0f;
    }
    void initPlayhead(PlayHead& ph, int64 graincounter, int64 outputpos, 
                    float grainsize, float grainposition, float grainpitch)
    {
       
        ph.isActive = true;
        ph.outPlaypos = 0;
        // use most of the knob range in the shorter sizes
        float sz = pow(grainsize, 3.0f);
        sz = 0.01f + 0.99f * sz;
        ph.lenSamples = int(processor.frequency * sz);
        float randomPos = grainposition + getBipolarRandom(positionrand,rng)*0.5f;
        randomPos = clamp(randomPos,0.0f,1.0f);
        let mindelay = int(processor.frequency * 0.05);
        let maxdelay = int(processor.frequency * 4.0);
        let delaytime = int(mindelay + randomPos * (maxdelay - mindelay));
        ph.sourceReadPos = float64(wrap<maxDelayLength>(writeIndex - delaytime));
        float pitch = grainpitch + getBipolarRandom(pitchrand,rng)*12.0f;
        // allow the modulations to go a bit past the normal range of the pitch :-)
        pitch = clamp(pitch, -18.0f, 18.0f);
        let rate = pow(2.0f, pitch / 12.0f);
        ph.playRate = rate;
        int fadelen = int(ph.lenSamples / 2 * grainshape);
        fadelen = clamp(fadelen,32,ph.lenSamples/2);
        ph.fadelensamples = fadelen;
        float panpos = 0.0f;
        if (int(panmode) == 1)
            panpos = -1.0f + 2.0f * (graincounter % 2);
        if (int(panmode) == 2)
            panpos = float(0.95 * sin(2*pi/processor.frequency*outputpos*0.25));
        ph.pangains = std::pan_law::centre3dB(panpos);
        
    }
    void main()
    {
        writeIndex = maxDelayLength - 1;
        float64 grainPhasor = 0.0f;
        float64 rate = 0.0;
        int64 graincounter = 0;
        int64 outputpos = 0;
        int numActivePlayheads = 0;
        loop
        {
            float<2> dry_in = audio_in;
            if (inputFrozen<0.5f)
            {
                delayBuffer[writeIndex] = (audio_in[0],audio_in[1]);
                writeIndex++;
            }
            
            if (grainPhasor == 0.0)
            {
                if (grainrate>0.0)
                {
                    float64 secondsavg = 1.0/pow(2.0, grainrate*6.0);
                    // Might be nice to have some of these random distributions in the 
                    // Cmajor standard lib, like exponential, Gauss, Cauchy...
                    float64 seconds = -log(rng.getUnipolar())*secondsavg; // exponential distribution
                    seconds = clamp(seconds,0.001,1.0);
                    rate = 1.0/seconds;
                } else if (grainrate<0.0)
                {
                    rate = pow(2.0, abs(grainrate)*6.0);
                } else
                {
                    rate = 0.0;
                }
                if (rate>0.0 && rng.getUnipolar()<grainChance)
                {
                    for (wrap<numPlayheads> i)
                    {
                        if (!playheads[i].isActive)
                        {
                            initPlayhead(playheads[i],graincounter,outputpos, 
                                grainsize, grainposition, grainpitch);
                            graincounter++;
                            numActivePlayheads++;
                            break;
                        }
                    }
                }
                   
            }
            grainPhasor += 1.0 / processor.frequency * rate;
            if (grainPhasor >= 1.0)
            {
                // this isn't the best way to do this but it's easier to detect the phasor resetted
                // this way
                grainPhasor = 0.0;
            }
            outputpos++;
            float outLeft = 0.0f;
            float outRight = 0.0f;
            for (wrap<numPlayheads> i)
            {
                if (rate>0.0 && playheads[i].isActive)
                {
                    float64 gain = 1.0;
                    int fadelen = playheads[i].fadelensamples;
                    int fadeoutstart = playheads[i].lenSamples-fadelen;
                    int phoutpos = playheads[i].outPlaypos;
                    if (phoutpos < fadelen)
                        gain = 1.0/fadelen*phoutpos;
                    if (phoutpos >= fadeoutstart)
                        gain = 1.0 - (1.0 / (fadelen-1) * (phoutpos-fadeoutstart));
                    let sourceReadIndex0 = wrap<maxDelayLength>(floor(playheads[i].sourceReadPos));
                    let sourceReadIndex1 = wrap<maxDelayLength>(sourceReadIndex0 + 1);
                    let frac = playheads[i].sourceReadPos - int(playheads[i].sourceReadPos);
                    let vy0 = delayBuffer[sourceReadIndex0];
                    let vy1 = delayBuffer[sourceReadIndex1];
                    let vinterp = vy0 + (vy1 - vy0) * frac;
                    let pangains = playheads[i].pangains;
                    outLeft += float(gain) * float(vinterp[0]) * pangains[0];
                    outRight += float(gain) * float(vinterp[1]) * pangains[1];
                    
                    playheads[i].sourceReadPos += playheads[i].playRate;
                    playheads[i].outPlaypos++;
                    if (playheads[i].outPlaypos == playheads[i].lenSamples)
                    {
                        playheads[i].isActive = false;
                        numActivePlayheads--;
                    }
                }
                
                
            }
            let tempnumplayheads = clamp(numActivePlayheads,0,numPlayheads);
            // not really based on anything, just attenuate the mix level some when more
            // playheads are playing simultaneously
            float gainCompens = 1.0f - tempnumplayheads * 0.025f;
            // the tanh shaping is pretty rough, should make optional/adjustable
            float<2> wet = (mainvol * tanh(outLeft * gainCompens),mainvol * tanh(outRight * gainCompens));
            // (mainvol * tanh(outLeft * 0.5f),mainvol*tanh(outRight * 0.5f))
            audio_out <- drywet * wet + (1.0f-drywet) * dry_in;
            advance();
        }
        
    }
}
