graph graindelay  [[ main ]]
{
    input stream float<2> audio_in;
    output stream float<2> audio_out;
    
    input value float freezeInput [[ name: "Freeze input", text: "off|on", boolean ]];
    input value float density [[ name: "Density", min: -1.0f, max: 1.0f, init: 0.0f ]];
    input value float size [[ name: "Size", min: 0.0f, max: 1.0f, init: 0.5f ]];
    input value float position [[ name: "Position", min: 0.0f, max: 1.0f, init: 0.5f ]];
    input value float pitch [[ name: "Pitch", min: -12.0f, max: 12.0f, init: 0.0f ]];
    input value float chance [[ name: "Probability", min: 0.0f, max: 1.0f, init: 1.0f ]];
    
    node engine = GrainDelayEngine;
    connection
    {
        audio_in -> engine.audio_in;
        density -> engine.grainrate;
        position -> engine.grainposition;
        size -> engine.grainsize;
        pitch -> engine.grainpitch;
        freezeInput -> engine.inputFrozen;
        chance -> engine.grainChance;
        engine.audio_out -> audio_out;
    }
}

processor GrainDelayEngine
{
    input stream float<2> audio_in;
    input stream float grainposition;
    input stream float grainrate;
    input stream float grainsize;
    input stream float grainpitch;
    input stream float inputFrozen;
    input stream float grainChance;
    input stream float feedBack;
    output stream float<2> audio_out;
    output stream float audio_out_right;
    let maxDelayLength = 10 * 44100;
    float<2>[maxDelayLength] delayBuffer;
    wrap<maxDelayLength> writeIndex;
    struct PlayHead
    {
        bool isActive;
        float64 sourceReadPos;
        int lenSamples;
        int outPlaypos;
        float playRate;
    }
    let numPlayheads = 32;
    PlayHead[numPlayheads] playheads;
    std::random::RNG rng;
    void init()
    {
        writeIndex = maxDelayLength - 1;
    }
    void main()
    {
        float64 grainPhasor = 0.0f;
        float64 rate = 0.0;
        loop
        {
            if (inputFrozen<0.5f)
            {
                delayBuffer[writeIndex] = (audio_in[0],audio_in[1]);
                writeIndex++;
            }
            
            if (grainPhasor == 0.0)
            {
                rate = pow(2.0, abs(grainrate)*6.0);
                if (grainrate>0.0)
                {
                    rate = -log(rng.getUnipolar())*rate;
                } else
                {
                    
                }
                if (rng.getUnipolar()<grainChance)
                {
                    for (wrap<numPlayheads> i)
                    {
                        if (!playheads[i].isActive)
                        {
                            playheads[i].isActive = true;
                            playheads[i].outPlaypos = 0;
                            let sz = 0.01+grainsize*0.9;
                            playheads[i].lenSamples = int(processor.frequency * sz);
                            let randomPos = grainposition + rng.getUnipolar() * 0.00;
                            let mindelay = 4096;
                            let maxdelay = int(processor.frequency * 4.0);
                            let delaytime = int(mindelay + randomPos * maxdelay);
                            playheads[i].sourceReadPos = float64(wrap<maxDelayLength>(writeIndex - delaytime));
                            let rate = pow(2.0f,grainpitch/12.0f);
                            playheads[i].playRate = rate;
                            // console <- "started grain " <- i <- "\n";
                            break;
                        }
                    }
                }
                   
            }
            if (rate>0.0)
            {
                grainPhasor += 1.0 / processor.frequency * rate;
                if (grainPhasor >= 1.0)
                {
                    grainPhasor = 0.0;
                }
            }
            
            float outLeft = 0.0f;
            float outRight = 0.0f;
            for (wrap<numPlayheads> i)
            {
                if (playheads[i].isActive)
                {
                    float64 gain = 1.0;
                    let halflen = playheads[i].lenSamples / 2;
                    if (playheads[i].outPlaypos < halflen)
                        gain = 1.0/halflen*playheads[i].outPlaypos;
                    if (playheads[i].outPlaypos >= halflen)
                        gain = 1.0 - (1.0 / halflen * (playheads[i].outPlaypos-halflen));
                    let sourceReadIndex0 = wrap<maxDelayLength>(floor(playheads[i].sourceReadPos));
                    let sourceReadIndex1 = wrap<maxDelayLength>(sourceReadIndex0 + 1);
                    let frac = playheads[i].sourceReadPos - int(playheads[i].sourceReadPos);
                    let y0left = delayBuffer[sourceReadIndex0][0];
                    let y1left = delayBuffer[sourceReadIndex1][0];
                    let interpLeft = y0left+(y1left-y0left)*frac;
                    outLeft += float(gain) * float(interpLeft);
                    let y0right = delayBuffer[sourceReadIndex0][1];
                    let y1right = delayBuffer[sourceReadIndex1][1];
                    let interpRight = y0right+(y1right-y0right)*frac;
                    outRight += float(gain) * float(interpRight);
                    playheads[i].sourceReadPos+=playheads[i].playRate;
                    playheads[i].outPlaypos++;
                    if (playheads[i].outPlaypos==playheads[i].lenSamples)
                    {
                        playheads[i].isActive = false;
                    }
                }
                
                
            }
            audio_out <- (tanh(outLeft * 0.5f),tanh(outRight * 0.5f));
            advance();
        }
        
    }
}
