/*
A rather primitive granular delay. 
Best Cmajor practices are not probably followed, the code is pretty
much a port of some C++ code I did recently.

-Xenakios
*/

graph graindelay  [[ main ]]
{
    input stream float<2> audio_in;
    output stream float<2> audio_out;
    
    input value float freezeInput [[ name: "Freeze input", text: "off|on", boolean ]];
    input value float density [[ name: "Density", min: -1.0f, max: 1.0f, init: 0.0f ]];
    input value float size [[ name: "Size", min: 0.0f, max: 1.0f, init: 0.5f ]];
    input value float shape [[ name: "Shape", min: 0.0f, max: 1.0f, init: 1.0f ]];
    input value float position [[ name: "Position", min: 0.0f, max: 1.0f, init: 0.5f ]];
    input value float pitch [[ name: "Pitch", min: -12.0f, max: 12.0f, init: 0.0f ]];
    input value float chance [[ name: "Probability", min: 0.0f, max: 1.0f, init: 1.0f ]];
    input value float mainvol [[ name: "Output gain", min: 0.0f, max: 1.0f, init: 0.1f ]];
    node engine = GrainDelayEngine;
    connection
    {
        audio_in -> engine.audio_in;
        density -> engine.grainrate;
        position -> engine.grainposition;
        size -> engine.grainsize;
        pitch -> engine.grainpitch;
        freezeInput -> engine.inputFrozen;
        chance -> engine.grainChance;
        mainvol -> engine.mainvol;
        shape -> engine.grainshape;
        engine.audio_out -> audio_out;
    }
}

processor GrainDelayEngine
{
    input stream float<2> audio_in;
    input stream float grainposition;
    input stream float grainrate;
    input stream float grainsize;
    input stream float grainpitch;
    input stream float grainshape;
    input stream float inputFrozen;
    input stream float grainChance;
    input stream float mainvol;
    output stream float<2> audio_out;
    
    let maxDelayLength = 10 * 44100;
    float<2>[maxDelayLength] delayBuffer;
    wrap<maxDelayLength> writeIndex;
    struct PlayHead
    {
        bool isActive;
        float64 sourceReadPos;
        int lenSamples;
        int outPlaypos;
        float playRate;
        int fadelensamples;
        float<2> pangains;
    }
    let numPlayheads = 32;
    PlayHead[numPlayheads] playheads;
    std::random::RNG rng;
    void init()
    {
        writeIndex = maxDelayLength - 1;
    }
    void main()
    {
        float64 grainPhasor = 0.0f;
        float64 rate = 0.0;
        int64 graincounter = 0;
        int64 outputpos = 0;
        loop
        {
            if (inputFrozen<0.5f)
            {
                delayBuffer[writeIndex] = (audio_in[0],audio_in[1]);
                writeIndex++;
            }
            
            if (grainPhasor == 0.0)
            {
                if (grainrate>0.0)
                {
                    float64 secondsavg = 1.0/pow(2.0, grainrate*6.0);
                    // Might be nice to have some of these random distributions in the 
                    // Cmajor standard lib, like exponential, Gauss, Cauchy...
                    float64 seconds = -log(rng.getUnipolar())*secondsavg; // exponential distribution
                    seconds = clamp(seconds,0.001,1.0);
                    rate = 1.0/seconds;
                } else if (grainrate<0.0)
                {
                    rate = pow(2.0, abs(grainrate)*6.0);
                } else
                {
                    rate = 0.0;
                }
                if (abs(rate)>0.0 && rng.getUnipolar()<grainChance)
                {
                    for (wrap<numPlayheads> i)
                    {
                        if (!playheads[i].isActive)
                        {
                            playheads[i].isActive = true;
                            playheads[i].outPlaypos = 0;
                            // use most of the knob range in the shorter sizes
                            float sz = pow(grainsize, 3.0f);
                            sz = 0.01f + 0.99f * sz;
                            playheads[i].lenSamples = int(processor.frequency * sz);
                            let randomPos = grainposition + rng.getUnipolar() * 0.00;
                            let mindelay = 4096;
                            let maxdelay = int(processor.frequency * 4.0);
                            let delaytime = int(mindelay + randomPos * maxdelay);
                            playheads[i].sourceReadPos = float64(wrap<maxDelayLength>(writeIndex - delaytime));
                            let rate = pow(2.0f,grainpitch/12.0f);
                            playheads[i].playRate = rate;
                            int fadelen = int(playheads[i].lenSamples / 2 * grainshape);
                            fadelen = clamp(fadelen,32,playheads[i].lenSamples/2);
                            playheads[i].fadelensamples = fadelen;
                            float panpos = float(0.95*sin(2*pi/processor.frequency*outputpos*0.25));
                            playheads[i].pangains = std::pan_law::centre3dB(panpos);
                            graincounter++;
                            // console <- "started grain " <- i <- "\n";
                            break;
                        }
                    }
                }
                   
            }
            grainPhasor += 1.0 / processor.frequency * rate;
            if (grainPhasor >= 1.0)
            {
                // this isn't the best way to do this but it's easier to detect the phasor resetted
                // this way
                grainPhasor = 0.0;
            }
            outputpos++;
            float outLeft = 0.0f;
            float outRight = 0.0f;
            for (wrap<numPlayheads> i)
            {
                if (rate>0.0 && playheads[i].isActive)
                {
                    float64 gain = 1.0;
                    int fadelen = playheads[i].fadelensamples;
                    int fadeoutstart = playheads[i].lenSamples-fadelen;
                    int phoutpos = playheads[i].outPlaypos;
                    if (phoutpos < fadelen)
                        gain = 1.0/fadelen*phoutpos;
                    if (phoutpos >= fadeoutstart)
                        gain = 1.0 - (1.0 / (fadelen-1) * (phoutpos-fadeoutstart));
                    let sourceReadIndex0 = wrap<maxDelayLength>(floor(playheads[i].sourceReadPos));
                    let sourceReadIndex1 = wrap<maxDelayLength>(sourceReadIndex0 + 1);
                    let frac = playheads[i].sourceReadPos - int(playheads[i].sourceReadPos);
                    let vy0 = delayBuffer[sourceReadIndex0];
                    let vy1 = delayBuffer[sourceReadIndex1];
                    let vinterp = vy0 + (vy1 - vy0) * frac;
                    let pangains = playheads[i].pangains;
                    outLeft += float(gain) * float(vinterp[0]) * pangains[0];
                    outRight += float(gain) * float(vinterp[1]) * pangains[1];
                    
                    playheads[i].sourceReadPos += playheads[i].playRate;
                    playheads[i].outPlaypos++;
                    if (playheads[i].outPlaypos == playheads[i].lenSamples)
                    {
                        playheads[i].isActive = false;
                    }
                }
                
                
            }
            // the tanh shaping is pretty rough, should make optional/adjustable
            audio_out <- (mainvol * tanh(outLeft * 0.5f),mainvol*tanh(outRight * 0.5f));
            advance();
        }
        
    }
}
