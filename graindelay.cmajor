graph graindelay  [[ main ]]
{
    input stream float<2> audio_in;
    // input stream float audio_in_right;
    output stream float audio_out_left;
    output stream float audio_out_right;
    input value float density [[ name: "Grain density", min: 0.0f, max: 1.0f, init: 0.5f ]];
    input value float size [[ name: "Grain size", min: 0.0f, max: 1.0f, init: 0.5f ]];
    input value float position [[ name: "Grain position", min: 0.0f, max: 1.0f, init: 0.5f ]];
    input value float pitch [[ name: "Grain pitch", min: -12.0f, max: 12.0f, init: 0.0f ]];
    
    node engine = GrainDelayEngine;
    // This is our processor's entry-point function, which is invoked
    // by the system
    connection
    {
        audio_in -> engine.audio_in;
        density -> engine.grainrate;
        position -> engine.grainposition;
        size -> engine.grainsize;
        pitch -> engine.grainpitch;
        engine.audio_out_left -> audio_out_left;
        engine.audio_out_right -> audio_out_right;
    }

    let volume = 0.15f;
    
}

processor GrainDelayEngine
{
    input stream float<2> audio_in;
    input stream float grainposition;
    input stream float grainrate;
    input stream float grainsize;
    input stream float grainpitch;
    output stream float audio_out_left;
    output stream float audio_out_right;
    let maxDelayLength = 10 * 44100;
    float<2>[maxDelayLength] delayBuffer;
    wrap<maxDelayLength> writeIndex;
    struct PlayHead
    {
        bool isActive;
        float64 sourceReadPos;
        int lenSamples;
        int outPlaypos;
        float playRate;
    }
    let numPlayheads = 32;
    PlayHead[numPlayheads] playheads;
    std::random::RNG rng;
    void init()
    {
        writeIndex = maxDelayLength - 1;
    }
    void main()
    {
        float64 grainPhasor = 0.0f;
        loop
        {
            delayBuffer[writeIndex][0] = audio_in[0];
            delayBuffer[writeIndex][1] = audio_in[1];
            writeIndex++;
            if (grainPhasor == 0.0)
            {
                for (wrap<numPlayheads> i)
                {
                    if (!playheads[i].isActive)
                    {
                        playheads[i].isActive = true;
                        playheads[i].outPlaypos = 0;
                        let sz = 0.01+grainsize*0.9;
                        playheads[i].lenSamples = int(processor.frequency * sz);
                        let delaytime = int(4096 + grainposition * 44100);
                        playheads[i].sourceReadPos = float64(wrap<maxDelayLength>(writeIndex - delaytime));
                        let rate = pow(2.0f,grainpitch/12.0f);
                        playheads[i].playRate = rate;
                        // console <- "started grain " <- i <- "\n";
                        break;
                    }
                }   
            }
            let rate = pow(2.0, grainrate*4.0);
            grainPhasor += 1.0 / processor.frequency * rate;
            if (grainPhasor >= 1.0)
            {
                grainPhasor = 0.0;
            }
            float outLeft = 0.0f;
            float outRight = 0.0f;
            for (wrap<numPlayheads> i)
            {
                if (playheads[i].isActive)
                {
                    float64 gain = 1.0;
                    let halflen = playheads[i].lenSamples / 2;
                    if (playheads[i].outPlaypos < halflen)
                        gain = 1.0/halflen*playheads[i].outPlaypos;
                    if (playheads[i].outPlaypos >= halflen)
                        gain = 1.0 - (1.0 / halflen * (playheads[i].outPlaypos-halflen));
                    let sourceReadIndex0 = wrap<maxDelayLength>(floor(playheads[i].sourceReadPos));
                    let sourceReadIndex1 = wrap<maxDelayLength>(sourceReadIndex0 + 1);
                    let frac = playheads[i].sourceReadPos - int(playheads[i].sourceReadPos);
                    let y0left = delayBuffer[sourceReadIndex0][0];
                    let y1left = delayBuffer[sourceReadIndex1][0];
                    let interpLeft = y0left+y1left*frac;
                    outLeft += float(gain) * float(interpLeft);
                    let y0right = delayBuffer[sourceReadIndex0][1];
                    let y1right = delayBuffer[sourceReadIndex1][1];
                    let interpRight = y0right+y1right*frac;
                    outRight += float(gain) * float(interpRight);
                    playheads[i].sourceReadPos+=playheads[i].playRate;
                    playheads[i].outPlaypos++;
                    if (playheads[i].outPlaypos==playheads[i].lenSamples)
                    {
                        playheads[i].isActive = false;
                    }
                }
                
                
            }
            audio_out_left <- outLeft * 0.5f;
            audio_out_right <- outRight * 0.5f;
            
            advance();
        }
        
    }
}
